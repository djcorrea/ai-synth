/**
 * üéØ SCORING V2 - SISTEMA JUSTO E SUAVE (BROWSER VERSION)
 * =======================================================
 * 
 * Implementa scoring melhorado com toler√¢ncias realistas e penalidades suaves
 * Vers√£o simplificada para browser sem depend√™ncias de filesystem
 */

// üéØ CONFIGURA√á√ÉO POR G√äNERO
const GENRE_WEIGHTS = {
    funk_mandela: {
        loudness: 0.25,    // LUFS √© fundamental
        dynamics: 0.15,    // DR importante mas n√£o cr√≠tico
        peak: 0.15,        // True peak controlado
        tonal: 0.25,       // Frequ√™ncias caracter√≠sticas
        stereo: 0.10,      // Imagem est√©reo complementar
        artifacts: 0.10    // Toler√¢ncia a artifacts
    },
    eletronico: {
        loudness: 0.20,    // Menos cr√≠tico que funk
        dynamics: 0.20,    // Din√¢mica mais importante
        peak: 0.10,        // Peak menos cr√≠tico
        tonal: 0.20,       // Frequ√™ncias importantes
        stereo: 0.15,      // Est√©reo mais importante
        artifacts: 0.15    // Qualidade t√©cnica importante
    },
    default: {
        loudness: 0.25,
        dynamics: 0.15,
        peak: 0.15,
        tonal: 0.25,
        stereo: 0.10,
        artifacts: 0.10
    }
};

// üéØ TARGETS POR G√äNERO (simplified)
const GENRE_TARGETS = {
    funk_mandela: {
        lufsIntegrated: { min: -16, ideal: -12, max: -8 },
        truePeak: { min: -6, ideal: -1, max: -0.1 },
        dynamicRange: { min: 3, ideal: 8, max: 20 },
        lra: { min: 2, ideal: 6, max: 12 },
        stereoCorrelation: { min: 0.3, ideal: 0.8, max: 1.0 }
    },
    eletronico: {
        lufsIntegrated: { min: -14, ideal: -10, max: -6 },
        truePeak: { min: -3, ideal: -0.5, max: -0.1 },
        dynamicRange: { min: 2, ideal: 5, max: 15 },
        lra: { min: 1, ideal: 4, max: 8 },
        stereoCorrelation: { min: 0.2, ideal: 0.7, max: 1.0 }
    },
    default: {
        lufsIntegrated: { min: -16, ideal: -14, max: -8 },
        truePeak: { min: -6, ideal: -1, max: -0.1 },
        dynamicRange: { min: 3, ideal: 8, max: 20 },
        lra: { min: 2, ideal: 6, max: 12 },
        stereoCorrelation: { min: 0.3, ideal: 0.8, max: 1.0 }
    }
};

// üéØ QUALITY GATES
const QUALITY_GATES = {
    critical: {
        maxScore: 40,
        conditions: [
            { metric: 'truePeak', threshold: -0.1, operator: '>' }
        ]
    },
    severe: {
        maxScore: 60,
        conditions: [
            { metric: 'dcOffset', threshold: 0.01, operator: '>' }
        ]
    },
    moderate: {
        maxScore: 75,
        conditions: [
            { metric: 'clippingPercent', threshold: 1.0, operator: '>' }
        ]
    }
};

/**
 * üßÆ FUN√á√ÉO PRINCIPAL DO SCORING V2
 */
export function calculateScoringV2(technicalData = {}, reference = null, options = {}) {
    console.log('üéØ [SCORING_V2] Iniciando c√°lculo V2...', { options });
    
    const startTime = performance.now();
    
    try {
        // Determinar g√™nero baseado na refer√™ncia ou dados
        const genre = detectGenre(reference, technicalData);
        const weights = GENRE_WEIGHTS[genre] || GENRE_WEIGHTS.default;
        const targets = GENRE_TARGETS[genre] || GENRE_TARGETS.default;
        
        console.log(`üéµ [SCORING_V2] G√™nero detectado: ${genre}`, { weights });
        
        // üìä CALCULAR SCORES POR CATEGORIA
        const categoryScores = calculateCategoryScores(technicalData, targets, weights, options);
        
        // üéØ SCORING GAUSSIANO SUAVE
        const rawScore = calculateWeightedScore(categoryScores, weights);
        
        // üõ°Ô∏è APLICAR QUALITY GATES
        const finalScore = applyQualityGates(rawScore, technicalData, options);
        
        // üìä RESULTADO FINAL
        const result = {
            scorePct: Math.max(15, Math.min(100, Math.round(finalScore))), // Entre 15% e 100%
            classification: classifyScore(finalScore),
            method: 'v2_gaussian',
            genre: genre,
            
            // Detalhes t√©cnicos
            details: {
                categoryScores: categoryScores,
                rawScore: rawScore,
                finalScore: finalScore,
                weights: weights,
                targets: targets,
                appliedGates: getAppliedGates(technicalData)
            },
            
            // Metadados
            processingTime: performance.now() - startTime,
            version: 'v2.0.0-browser',
            timestamp: new Date().toISOString()
        };
        
        console.log(`‚úÖ [SCORING_V2] Score calculado: ${result.scorePct}% (${result.classification})`);
        
        return result;
        
    } catch (error) {
        console.error('‚ùå [SCORING_V2] Erro no c√°lculo:', error);
        throw error;
    }
}

/**
 * üîç DETECTAR G√äNERO
 */
function detectGenre(reference, technicalData) {
    // Se h√° refer√™ncia espec√≠fica
    if (reference && reference.genre) {
        return reference.genre;
    }
    
    // Detectar pelo window global (se dispon√≠vel)
    if (typeof window !== 'undefined') {
        const activeGenre = window.PROD_AI_REF_GENRE;
        if (activeGenre && GENRE_WEIGHTS[activeGenre]) {
            return activeGenre;
        }
    }
    
    // Fallback para default
    return 'default';
}

/**
 * üìä CALCULAR SCORES POR CATEGORIA
 */
function calculateCategoryScores(technicalData, targets, weights, options) {
    const categories = {};
    
    // Loudness
    categories.loudness = scoreLoudness(technicalData, targets);
    
    // Dynamics
    categories.dynamics = scoreDynamics(technicalData, targets);
    
    // Peak
    categories.peak = scorePeak(technicalData, targets);
    
    // Tonal (simplificado)
    categories.tonal = scoreTonal(technicalData, targets);
    
    // Stereo
    categories.stereo = scoreStereo(technicalData, targets);
    
    // Artifacts
    categories.artifacts = scoreArtifacts(technicalData, targets);
    
    return categories;
}

/**
 * üîä SCORE LOUDNESS (LUFS)
 */
function scoreLoudness(data, targets) {
    const lufs = data.lufsIntegrated;
    if (!Number.isFinite(lufs)) return 50; // Neutro se n√£o dispon√≠vel
    
    const target = targets.lufsIntegrated;
    return scoreGaussian(lufs, target.ideal, (target.max - target.min) / 4);
}

/**
 * üìà SCORE DYNAMICS
 */
function scoreDynamics(data, targets) {
    const dr = data.dynamicRange || data.dr;
    if (!Number.isFinite(dr)) return 50;
    
    const target = targets.dynamicRange;
    return scoreGaussian(dr, target.ideal, (target.max - target.min) / 4);
}

/**
 * ‚ö° SCORE PEAK
 */
function scorePeak(data, targets) {
    const truePeak = data.truePeakDbtp;
    if (!Number.isFinite(truePeak)) return 50;
    
    const target = targets.truePeak;
    
    // Penalizar mais severamente picos acima de -0.1 dBTP
    if (truePeak > -0.1) {
        return Math.max(0, 40 - (truePeak + 0.1) * 100); // Penaliza√ß√£o severa
    }
    
    return scoreGaussian(truePeak, target.ideal, (target.max - target.min) / 4);
}

/**
 * üéµ SCORE TONAL (simplificado)
 */
function scoreTonal(data, targets) {
    // Score simplificado baseado em bandas se dispon√≠veis
    if (data.bandEnergies) {
        const bandScores = [];
        
        for (const [bandName, bandData] of Object.entries(data.bandEnergies)) {
            if (bandData && Number.isFinite(bandData.rms_db)) {
                // Assumir target neutro para bandas sem refer√™ncia espec√≠fica
                const score = scoreGaussian(bandData.rms_db, -7, 3);
                bandScores.push(score);
            }
        }
        
        if (bandScores.length > 0) {
            return bandScores.reduce((a, b) => a + b) / bandScores.length;
        }
    }
    
    // Fallback para score neutro
    return 70; // Assumir OK se n√£o h√° dados de banda
}

/**
 * üéß SCORE STEREO
 */
function scoreStereo(data, targets) {
    const correlation = data.stereoCorrelation;
    if (!Number.isFinite(correlation)) return 50;
    
    const target = targets.stereoCorrelation;
    return scoreGaussian(correlation, target.ideal, (target.max - target.min) / 4);
}

/**
 * üîß SCORE ARTIFACTS
 */
function scoreArtifacts(data, targets) {
    let artifactScore = 100; // Come√ßar com pontua√ß√£o m√°xima
    
    // Penalizar DC offset
    const dcOffset = Math.abs(data.dcOffset || 0);
    if (dcOffset > 0.001) {
        artifactScore -= dcOffset * 1000; // Penaliza√ß√£o por DC offset
    }
    
    // Penalizar clipping
    const clipping = data.clippingPercent || data.clippingSamples || 0;
    if (clipping > 0) {
        artifactScore -= clipping * 10; // Penaliza√ß√£o por clipping
    }
    
    return Math.max(0, Math.min(100, artifactScore));
}

/**
 * üßÆ FUN√á√ÉO GAUSSIANA PARA SCORING SUAVE
 */
function scoreGaussian(value, ideal, sigma) {
    if (!Number.isFinite(value) || !Number.isFinite(ideal) || !Number.isFinite(sigma) || sigma <= 0) {
        return 50; // Score neutro se dados inv√°lidos
    }
    
    const diff = Math.abs(value - ideal);
    const gaussianScore = Math.exp(-0.5 * Math.pow(diff / sigma, 2)) * 100;
    
    return Math.max(0, Math.min(100, gaussianScore));
}

/**
 * ‚öñÔ∏è CALCULAR SCORE PONDERADO
 */
function calculateWeightedScore(categoryScores, weights) {
    let weightedSum = 0;
    let totalWeight = 0;
    
    for (const [category, weight] of Object.entries(weights)) {
        const score = categoryScores[category];
        if (Number.isFinite(score)) {
            weightedSum += score * weight;
            totalWeight += weight;
        }
    }
    
    return totalWeight > 0 ? weightedSum / totalWeight : 50;
}

/**
 * üõ°Ô∏è APLICAR QUALITY GATES
 */
function applyQualityGates(rawScore, technicalData, options) {
    if (!options.enableQualityGates) {
        return rawScore;
    }
    
    let finalScore = rawScore;
    
    // Verificar gates cr√≠ticos
    for (const [gateName, gate] of Object.entries(QUALITY_GATES)) {
        for (const condition of gate.conditions) {
            const metricValue = technicalData[condition.metric];
            
            if (Number.isFinite(metricValue)) {
                let conditionMet = false;
                
                switch (condition.operator) {
                    case '>':
                        conditionMet = metricValue > condition.threshold;
                        break;
                    case '<':
                        conditionMet = metricValue < condition.threshold;
                        break;
                    case '>=':
                        conditionMet = metricValue >= condition.threshold;
                        break;
                    case '<=':
                        conditionMet = metricValue <= condition.threshold;
                        break;
                }
                
                if (conditionMet) {
                    console.log(`üõ°Ô∏è [QUALITY_GATE] Aplicando gate ${gateName}: max ${gate.maxScore}%`);
                    finalScore = Math.min(finalScore, gate.maxScore);
                }
            }
        }
    }
    
    return finalScore;
}

/**
 * üè∑Ô∏è CLASSIFICAR SCORE
 */
function classifyScore(score) {
    if (score >= 90) return 'Refer√™ncia Mundial';
    if (score >= 75) return 'Avan√ßado';
    if (score >= 60) return 'Intermedi√°rio';
    return 'B√°sico';
}

/**
 * üîç OBTER GATES APLICADOS
 */
function getAppliedGates(technicalData) {
    const applied = [];
    
    for (const [gateName, gate] of Object.entries(QUALITY_GATES)) {
        for (const condition of gate.conditions) {
            const metricValue = technicalData[condition.metric];
            
            if (Number.isFinite(metricValue)) {
                let conditionMet = false;
                
                switch (condition.operator) {
                    case '>':
                        conditionMet = metricValue > condition.threshold;
                        break;
                    case '<':
                        conditionMet = metricValue < condition.threshold;
                        break;
                }
                
                if (conditionMet) {
                    applied.push({
                        gate: gateName,
                        metric: condition.metric,
                        value: metricValue,
                        threshold: condition.threshold,
                        maxScore: gate.maxScore
                    });
                }
            }
        }
    }
    
    return applied;
}

// Global namespace para browser
window.ScoringV2 = {
    calculateScoringV2: calculateScoringV2
};

console.log('üéØ [SCORING_V2] M√≥dulo V2 carregado globalmente!');
