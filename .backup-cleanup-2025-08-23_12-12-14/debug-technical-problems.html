<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîç Debug: Problemas T√©cnicos</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; }
        .section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; }
        .code { font-family: monospace; background: #f8f8f8; padding: 10px; border-radius: 4px; white-space: pre-wrap; }
        .missing { color: #f44336; font-weight: bold; }
        .present { color: #4CAF50; font-weight: bold; }
        .debug-info { background: #e3f2fd; padding: 10px; border-radius: 4px; margin: 10px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Debug: Por que Problemas T√©cnicos n√£o aparecem?</h1>
        
        <div class="section">
            <h2>üìä Dados T√©cnicos Detectados</h2>
            <div id="technicalData" class="code">Carregando...</div>
        </div>
        
        <div class="section">
            <h2>üß™ Valida√ß√£o de M√©tricas</h2>
            <div id="metricsValidation" class="code">Carregando...</div>
        </div>
        
        <div class="section">
            <h2>üö® Diagn√≥stico do Problema</h2>
            <div id="diagnosis">Analisando...</div>
        </div>
        
        <div class="section">
            <h2>üéØ Upload de √Åudio para Teste</h2>
            <input type="file" id="audioFile" accept="audio/*" />
            <button onclick="analyzeAudio()">Analisar</button>
        </div>
    </div>

    <!-- Incluir o analisador -->
    <script src="./audio-analyzer.js"></script>
    <script>
        // Interceptar a fun√ß√£o de renderiza√ß√£o para capturar dados
        let lastAnalysisData = null;
        
        // Fun√ß√£o para interceptar dados
        function interceptAnalysisData() {
            // Monitorar o window para pegar dados quando dispon√≠veis
            if (window.lastAnalysisResult) {
                lastAnalysisData = window.lastAnalysisResult;
                displayTechnicalData();
            }
        }
        
        function displayTechnicalData() {
            if (!lastAnalysisData) return;
            
            const analysis = lastAnalysisData;
            
            // Mostrar dados t√©cnicos
            const techData = analysis.technicalData || {};
            document.getElementById('technicalData').innerHTML = JSON.stringify(techData, null, 2);
            
            // Mostrar valida√ß√£o de m√©tricas
            const metricsVal = analysis.metricsValidation || {};
            document.getElementById('metricsValidation').innerHTML = JSON.stringify(metricsVal, null, 2);
            
            // Diagn√≥stico
            let diagnosis = [];
            
            // Verificar clipping
            const clipSamples = techData.clippingSamples || 0;
            const clipPct = techData.clippingPct || 0;
            diagnosis.push(`Clipping Samples: ${clipSamples} ${clipSamples > 0 ? '‚úÖ Detectado' : '‚ùå Zero'}`);
            diagnosis.push(`Clipping %: ${clipPct} ${clipPct > 0 ? '‚úÖ Detectado' : '‚ùå Zero'}`);
            
            // Verificar DC Offset
            const dcOffset = techData.dcOffset || 0;
            diagnosis.push(`DC Offset: ${dcOffset} ${Math.abs(dcOffset) > 0.01 ? '‚úÖ Significativo' : '‚ùå Insignificante'}`);
            
            // Verificar m√©tricas de valida√ß√£o
            if (Object.keys(metricsVal).length > 0) {
                diagnosis.push(`Valida√ß√£o de M√©tricas: ‚úÖ Presente`);
                Object.entries(metricsVal).forEach(([key, value]) => {
                    diagnosis.push(`  - ${key}: ${value}`);
                });
            } else {
                diagnosis.push(`Valida√ß√£o de M√©tricas: ‚ùå Ausente`);
            }
            
            // Conclus√£o
            diagnosis.push('');
            diagnosis.push('üéØ CONCLUS√ÉO:');
            if (clipSamples === 0 && Math.abs(dcOffset) < 0.01 && Object.keys(metricsVal).length === 0) {
                diagnosis.push('‚ùå N√ÉO H√Å PROBLEMAS T√âCNICOS DETECTADOS');
                diagnosis.push('Isso explica por que o card aparece vazio!');
            } else {
                diagnosis.push('‚úÖ PROBLEMAS T√âCNICOS DETECTADOS');
                diagnosis.push('O card deveria mostrar informa√ß√µes.');
            }
            
            document.getElementById('diagnosis').innerHTML = `<div class="code">${diagnosis.join('\\n')}</div>`;
        }
        
        // Fun√ß√£o para analisar √°udio carregado
        async function analyzeAudio() {
            const fileInput = document.getElementById('audioFile');
            if (!fileInput.files[0]) {
                alert('Selecione um arquivo de √°udio primeiro!');
                return;
            }
            
            document.getElementById('technicalData').innerHTML = 'Analisando...';
            document.getElementById('metricsValidation').innerHTML = 'Analisando...';
            document.getElementById('diagnosis').innerHTML = 'Analisando...';
            
            try {
                // Simular an√°lise (voc√™ pode integrar com o analisador real aqui)
                const file = fileInput.files[0];
                const arrayBuffer = await file.arrayBuffer();
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // An√°lise b√°sica para debug
                const channelData = audioBuffer.getChannelData(0);
                let clippingSamples = 0;
                let dcSum = 0;
                
                for (let i = 0; i < channelData.length; i++) {
                    const sample = Math.abs(channelData[i]);
                    if (sample >= 0.99) clippingSamples++;
                    dcSum += channelData[i];
                }
                
                const dcOffset = dcSum / channelData.length;
                const clippingPct = (clippingSamples / channelData.length) * 100;
                
                // Simular dados de an√°lise
                lastAnalysisData = {
                    technicalData: {
                        clippingSamples: clippingSamples,
                        clippingPct: clippingPct,
                        dcOffset: dcOffset,
                        // Adicionar outros dados que o sistema espera
                        clippingSamplesTruePeak: clippingSamples
                    },
                    metricsValidation: {
                        // Simular valida√ß√µes quando aplic√°vel
                        dynamicRangeConsistency: clippingSamples > 100 ? 'warn' : 'ok',
                        crestFactorConsistency: 'ok',
                        lraPlausibility: 'ok'
                    }
                };
                
                displayTechnicalData();
                
            } catch (error) {
                document.getElementById('diagnosis').innerHTML = `<div class="missing">Erro na an√°lise: ${error.message}</div>`;
            }
        }
        
        // Tentar interceptar dados a cada segundo
        setInterval(interceptAnalysisData, 1000);
        
        // Debug inicial
        setTimeout(() => {
            if (!lastAnalysisData) {
                document.getElementById('technicalData').innerHTML = 'Nenhum dado de an√°lise encontrado. Carregue um √°udio no analisador principal ou use o upload acima.';
                document.getElementById('metricsValidation').innerHTML = 'Nenhum dado de valida√ß√£o encontrado.';
                document.getElementById('diagnosis').innerHTML = '<div class="missing">Para debugar, voc√™ precisa analisar um √°udio primeiro!</div>';
            }
        }, 2000);
    </script>
</body>
</html>
