#!/usr/bin/env node

import fs from 'fs/promises';
import fssync from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.join(__dirname, '..');

// Arquivos CR√çTICOS que nunca devem ser removidos
const CRITICAL_FILES = new Set([
    // Core do projeto
    'index.html', 'package.json', 'package-lock.json', 'vercel.json',
    'firebase.json', 'firestore.rules', 'storage.rules',
    
    // APIs
    'api/upload-audio.js', 'api/chat.js', 'api/payment.js',
    
    // Scripts funcionais
    'debug-analyzer.js', 'dev-server.js', 'dev-server-fixed.js',
    
    // Configura√ß√µes
    '.env', '.env.example', '.gitignore', 'README.md'
]);

// Diret√≥rios cr√≠ticos
const CRITICAL_DIRS = new Set([
    'public', 'api', 'tools', 'refs', 'samples', 
    'node_modules', '.git', '.vercel'
]);

// Padr√µes de arquivos SEGUROS para remo√ß√£o (documenta√ß√£o/debug)
const SAFE_REMOVAL_PATTERNS = [
    // Documenta√ß√£o de processo/debug
    /^ANALISE_.*\.md$/,
    /^AUDITORIA_.*\.md$/,
    /^CORRECAO_.*\.md$/,
    /^CHECKLIST_.*\.md$/,
    /^CONFIGURACAO_.*\.md$/,
    /^DIAGNOSTICO_.*\.md$/,
    /^ETAPA_.*\.md$/,
    /^FINAL_.*\.md$/,
    /^GUIA_.*\.md$/,
    /^HOTFIX_.*\.md$/,
    /^IMPLEMENTACAO_.*\.md$/,
    /^INVESTIGACAO_.*\.md$/,
    /^LIMITE_.*\.md$/,
    /^LOG_.*\.md$/,
    /^PATCH_.*\.md$/,
    /^PLANO_.*\.md$/,
    /^POST_.*\.md$/,
    /^PROBLEMA_.*\.md$/,
    /^RELATORIO_.*\.md$/,
    /^RESUMO_.*\.md$/,
    /^SISTEMA_.*\.md$/,
    /^STATUS_.*\.md$/,
    /^TESTE_.*\.md$/,
    /^UPLOAD_.*\.md$/,
    /^VERIFICACAO_.*\.md$/,
    /^ATUALIZACAO_.*\.md$/,
    
    // Scripts de configura√ß√£o tempor√°ria
    /^configurar-.*\.(ps1|sh)$/,
    /^limpar-.*\.ps1$/,
    
    // Relat√≥rios HTML de debug (n√£o funcionais)
    /^cache-diagnostic\.html$/,
    /^critical-error-report\.html$/,
    /^debug-score-.*\.html$/,
    /^debug-interpretation\.html$/,
    /^debug-suggestion-logic\.html$/,
    /^debug-technical-problems\.html$/,
    /^debug-subscore-precision\.html$/,
    /^debug-valores-problema\.html$/,
    /^correcao-.*\.html$/,
    /^diagnostic-.*\.html$/,
    /^validation-.*\.html$/,
    
    // Arquivos de texto tempor√°rios
    /^builder-.*\.txt$/,
    /^calibration-.*\.txt$/,
    /.*-report.*\.txt$/,
    /^cache-.*\.txt$/,
    
    // Scripts de corre√ß√£o pontuais vazios
    /^correcao-emergencia\.js$/,
    /^debug-server\.js$/,
    /^fix-bandas-direto\.js$/,
    
    // Arquivos vazios ou tempor√°rios
    /^deploy-trigger\.js$/
];

// Fun√ß√£o para verificar se um arquivo est√° sendo importado/usado
async function isFileReferenced(filePath, fileName, baseName) {
    const searchPatterns = [
        // Import/require diretos
        `import.*${fileName}`,
        `import.*${baseName}`,
        `require.*${fileName}`,
        `require.*${baseName}`,
        
        // Refer√™ncias em HTML
        `src=.*${fileName}`,
        `href=.*${fileName}`,
        
        // Refer√™ncias em strings
        `"${fileName}"`,
        `'${fileName}'`,
        `\`${fileName}\``,
        
        // Scripts npm
        `node ${fileName}`,
        `node ${baseName}`,
        
        // Paths relativos
        `../${fileName}`,
        `./${fileName}`,
        `/${fileName}`
    ];
    
    // Verificar package.json especificamente
    try {
        const packageContent = await fs.readFile(path.join(projectRoot, 'package.json'), 'utf8');
        const packageData = JSON.parse(packageContent);
        
        // Verificar scripts
        for (const script of Object.values(packageData.scripts || {})) {
            if (script.includes(fileName) || script.includes(baseName)) {
                return true;
            }
        }
    } catch (error) {
        // Ignorar se n√£o conseguir ler package.json
    }
    
    // Buscar em todos os arquivos do projeto
    const allFiles = await getAllFilesRecursive(projectRoot);
    
    for (const file of allFiles) {
        // Pular arquivos bin√°rios e irrelevantes
        if (isBinaryFile(file) || file.includes('node_modules') || file.includes('.git')) {
            continue;
        }
        
        try {
            const content = await fs.readFile(file, 'utf8');
            
            for (const pattern of searchPatterns) {
                const regex = new RegExp(pattern, 'i');
                if (regex.test(content)) {
                    return true;
                }
            }
        } catch (error) {
            // Ignorar arquivos que n√£o conseguimos ler
        }
    }
    
    return false;
}

// Fun√ß√£o para verificar se √© arquivo bin√°rio
function isBinaryFile(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    const binaryExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.ico', '.mp3', '.wav', '.mp4', '.zip', '.pdf'];
    return binaryExtensions.includes(ext);
}

// Fun√ß√£o para listar todos os arquivos recursivamente
async function getAllFilesRecursive(dir) {
    const files = [];
    
    async function traverse(currentDir) {
        try {
            const entries = await fs.readdir(currentDir, { withFileTypes: true });
            
            for (const entry of entries) {
                const fullPath = path.join(currentDir, entry.name);
                
                if (entry.isDirectory()) {
                    const relativePath = path.relative(projectRoot, fullPath);
                    if (!CRITICAL_DIRS.has(entry.name) && !relativePath.includes('node_modules')) {
                        await traverse(fullPath);
                    }
                } else {
                    files.push(fullPath);
                }
            }
        } catch (error) {
            // Ignorar diret√≥rios com erro de acesso
        }
    }
    
    await traverse(dir);
    return files;
}

// Fun√ß√£o principal de an√°lise
async function analyzeSafeRemoval() {
    console.log('üîç Analisando arquivos seguros para remo√ß√£o...\n');
    
    const allFiles = await getAllFilesRecursive(projectRoot);
    const safeForRemoval = [];
    const suspicious = [];
    const critical = [];
    
    let processed = 0;
    const total = allFiles.length;
    
    for (const filePath of allFiles) {
        const relativePath = path.relative(projectRoot, filePath).replace(/\\/g, '/');
        const fileName = path.basename(relativePath);
        const baseName = path.parse(fileName).name;
        
        processed++;
        if (processed % 50 === 0) {
            console.log(`üìä Processando ${processed}/${total} arquivos...`);
        }
        
        // Verificar se √© arquivo cr√≠tico
        if (CRITICAL_FILES.has(relativePath) || CRITICAL_FILES.has(fileName)) {
            critical.push({ path: relativePath, reason: 'Arquivo cr√≠tico do sistema' });
            continue;
        }
        
        // Verificar se corresponde aos padr√µes de remo√ß√£o segura
        const isSafePattern = SAFE_REMOVAL_PATTERNS.some(pattern => 
            pattern.test(fileName) || pattern.test(relativePath)
        );
        
        if (isSafePattern) {
            // Verificar se est√° sendo referenciado
            const isReferenced = await isFileReferenced(filePath, fileName, baseName);
            
            if (!isReferenced) {
                const stats = fssync.statSync(filePath);
                safeForRemoval.push({
                    path: relativePath,
                    size: stats.size,
                    lastModified: stats.mtime.toISOString().split('T')[0],
                    reason: 'Documenta√ß√£o/debug n√£o referenciado',
                    type: getFileType(fileName)
                });
            } else {
                suspicious.push({
                    path: relativePath,
                    reason: 'Arquivo de debug mas com refer√™ncias encontradas'
                });
            }
        }
    }
    
    return { safeForRemoval, suspicious, critical, total: processed };
}

function getFileType(fileName) {
    const ext = path.extname(fileName);
    if (!ext) return 'no-ext';
    return ext;
}

function formatBytes(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// Gerar relat√≥rio de remo√ß√£o segura
function generateSafeRemovalReport(analysis) {
    const { safeForRemoval, suspicious, critical } = analysis;
    
    let report = `# üóëÔ∏è Relat√≥rio de Arquivos Seguros para Remo√ß√£o\n\n`;
    report += `**Data:** ${new Date().toLocaleDateString('pt-BR')}\n`;
    report += `**An√°lise:** Apenas arquivos de documenta√ß√£o/debug sem refer√™ncias\n\n`;
    
    // Resumo
    const totalSize = safeForRemoval.reduce((sum, file) => sum + file.size, 0);
    report += `## üìä Resumo\n\n`;
    report += `- **Arquivos seguros para remo√ß√£o:** ${safeForRemoval.length}\n`;
    report += `- **Espa√ßo a ser liberado:** ${formatBytes(totalSize)}\n`;
    report += `- **Arquivos suspeitos (revisar):** ${suspicious.length}\n`;
    report += `- **Arquivos cr√≠ticos preservados:** ${critical.length}\n\n`;
    
    // Arquivos seguros para remo√ß√£o
    if (safeForRemoval.length > 0) {
        report += `## ‚úÖ Arquivos SEGUROS para Remo√ß√£o (${safeForRemoval.length})\n\n`;
        report += `| Arquivo | Tipo | Tamanho | √öltima Modifica√ß√£o | Motivo |\n`;
        report += `|---------|------|---------|-------------------|--------|\n`;
        
        safeForRemoval
            .sort((a, b) => b.size - a.size)
            .forEach(file => {
                report += `| \`${file.path}\` | ${file.type} | ${formatBytes(file.size)} | ${file.lastModified} | ${file.reason} |\n`;
            });
        report += `\n`;
    }
    
    // Arquivos suspeitos
    if (suspicious.length > 0) {
        report += `## ‚ö†Ô∏è Arquivos Suspeitos - REVISAR MANUALMENTE (${suspicious.length})\n\n`;
        report += `| Arquivo | Motivo |\n`;
        report += `|---------|--------|\n`;
        
        suspicious.forEach(file => {
            report += `| \`${file.path}\` | ${file.reason} |\n`;
        });
        report += `\n`;
    }
    
    // Estat√≠sticas por tipo
    const typeStats = {};
    safeForRemoval.forEach(file => {
        if (!typeStats[file.type]) {
            typeStats[file.type] = { count: 0, size: 0 };
        }
        typeStats[file.type].count++;
        typeStats[file.type].size += file.size;
    });
    
    if (Object.keys(typeStats).length > 0) {
        report += `## üìà Arquivos por Tipo\n\n`;
        report += `| Tipo | Quantidade | Tamanho Total |\n`;
        report += `|------|------------|---------------|\n`;
        
        Object.entries(typeStats)
            .sort((a, b) => b[1].size - a[1].size)
            .forEach(([type, stats]) => {
                report += `| ${type || 'sem extens√£o'} | ${stats.count} | ${formatBytes(stats.size)} |\n`;
            });
    }
    
    return report;
}

// Gerar script de remo√ß√£o segura
function generateSafeRemovalScript(analysis) {
    const { safeForRemoval } = analysis;
    
    let script = `# Script de Remo√ß√£o Segura - Apenas Documenta√ß√£o/Debug\n`;
    script += `# Data: ${new Date().toISOString()}\n`;
    script += `# Arquivos: ${safeForRemoval.length}\n\n`;
    
    script += `Write-Host "üóëÔ∏è Iniciando remo√ß√£o de arquivos de documenta√ß√£o/debug..."\n`;
    script += `Write-Host "üìÅ Total de arquivos: ${safeForRemoval.length}"\n\n`;
    
    script += `# Criar backup antes da remo√ß√£o\n`;
    script += `$backupDir = ".backup-$(Get-Date -Format 'yyyy-MM-dd-HHmm')"\n`;
    script += `New-Item -ItemType Directory -Path $backupDir -Force | Out-Null\n`;
    script += `Write-Host "üíæ Backup criado em: $backupDir"\n\n`;
    
    for (const file of safeForRemoval) {
        const backupPath = `$backupDir\\${file.path}`;
        const backupDir = path.dirname(backupPath);
        
        script += `# Removendo: ${file.path} (${formatBytes(file.size)})\n`;
        script += `if (Test-Path "${file.path}") {\n`;
        script += `    $backupFileDir = "${backupDir}\\${path.dirname(file.path)}"\n`;
        script += `    New-Item -ItemType Directory -Path $backupFileDir -Force | Out-Null\n`;
        script += `    Copy-Item "${file.path}" "$backupFileDir\\" -Force\n`;
        script += `    Remove-Item "${file.path}" -Force\n`;
        script += `    Write-Host "‚úÖ Removido: ${file.path}"\n`;
        script += `} else {\n`;
        script += `    Write-Host "‚ö†Ô∏è N√£o encontrado: ${file.path}"\n`;
        script += `}\n\n`;
    }
    
    const totalSize = safeForRemoval.reduce((sum, file) => sum + file.size, 0);
    script += `Write-Host "üéâ Remo√ß√£o conclu√≠da!"\n`;
    script += `Write-Host "üíæ Espa√ßo liberado: ${formatBytes(totalSize)}"\n`;
    script += `Write-Host "üì¶ Backup salvo em: $backupDir"\n`;
    script += `Write-Host "‚Ü©Ô∏è Para reverter: mova os arquivos do backup de volta"\n`;
    
    return script;
}

// Executar an√°lise
async function main() {
    try {
        console.log('üöÄ Executando an√°lise de remo√ß√£o segura...\n');
        
        const analysis = await analyzeSafeRemoval();
        
        // Gerar relat√≥rios
        const report = generateSafeRemovalReport(analysis);
        const script = generateSafeRemovalScript(analysis);
        const jsonData = JSON.stringify(analysis, null, 2);
        
        // Salvar arquivos
        const auditDir = path.join(projectRoot, 'audit');
        await fs.writeFile(path.join(auditDir, 'safe_removal_report.md'), report);
        await fs.writeFile(path.join(auditDir, 'safe_removal_script.ps1'), script);
        await fs.writeFile(path.join(auditDir, 'safe_removal_data.json'), jsonData);
        
        console.log('\nüìä AN√ÅLISE DE REMO√á√ÉO SEGURA CONCLU√çDA');
        console.log('==========================================');
        console.log(`‚úÖ Arquivos seguros para remo√ß√£o: ${analysis.safeForRemoval.length}`);
        console.log(`‚ö†Ô∏è Arquivos suspeitos (revisar): ${analysis.suspicious.length}`);
        console.log(`üõ°Ô∏è Arquivos cr√≠ticos preservados: ${analysis.critical.length}`);
        
        const totalSize = analysis.safeForRemoval.reduce((sum, file) => sum + file.size, 0);
        console.log(`üíæ Espa√ßo a ser liberado: ${formatBytes(totalSize)}`);
        console.log(`üìÑ Relat√≥rio: audit/safe_removal_report.md`);
        console.log(`üîß Script: audit/safe_removal_script.ps1`);
        console.log('==========================================\n');
        
    } catch (error) {
        console.error('‚ùå Erro durante an√°lise:', error.message);
        process.exit(1);
    }
}

main();
