<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ VALIDA√á√ÉO FINAL - Sub-Scores 100% Precisos</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px; 
        }
        .container { 
            max-width: 1400px; margin: 0 auto; 
            background: rgba(255,255,255,0.95); 
            border-radius: 16px; padding: 30px; 
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        h1 { 
            text-align: center; color: #2c3e50; margin-bottom: 30px; 
            font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        .validation-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
            gap: 20px; 
            margin: 25px 0;
        }
        
        .validation-card { 
            background: white; 
            border-radius: 12px; 
            padding: 20px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            border-left: 5px solid #007bff;
        }
        
        .validation-card.excellent { border-left-color: #28a745; }
        .validation-card.good { border-left-color: #ffc107; }
        .validation-card.critical { border-left-color: #dc3545; }
        
        .card-header { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 15px;
        }
        
        .card-title { 
            font-size: 1.3em; 
            font-weight: bold; 
            color: #495057;
        }
        
        .score-display { 
            font-size: 2em; 
            font-weight: bold; 
            color: #007bff;
        }
        
        .score-display.excellent { color: #28a745; }
        .score-display.good { color: #ffc107; }
        .score-display.critical { color: #dc3545; }
        
        .metrics-details { 
            margin-top: 15px; 
            font-size: 0.9em; 
            color: #6c757d;
        }
        
        .comparison-table { 
            width: 100%; 
            border-collapse: collapse; 
            margin: 20px 0; 
            background: white; 
            border-radius: 8px; 
            overflow: hidden; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
        }
        
        .comparison-table th, .comparison-table td { 
            border: 1px solid #dee2e6; 
            padding: 12px; 
            text-align: center;
        }
        
        .comparison-table th { 
            background: #f8f9fa; 
            font-weight: bold; 
            color: #495057;
        }
        
        .comparison-table tr:nth-child(even) { 
            background: #f8f9fa; 
        }
        
        .status-excellent { 
            background: #d4edda; 
            color: #155724; 
            padding: 5px 10px; 
            border-radius: 15px; 
            font-size: 0.85em; 
            font-weight: bold;
        }
        
        .status-good { 
            background: #fff3cd; 
            color: #856404; 
            padding: 5px 10px; 
            border-radius: 15px; 
            font-size: 0.85em; 
            font-weight: bold;
        }
        
        .status-critical { 
            background: #f8d7da; 
            color: #721c24; 
            padding: 5px 10px; 
            border-radius: 15px; 
            font-size: 0.85em; 
            font-weight: bold;
        }
        
        .summary { 
            background: linear-gradient(45deg, #e3f2fd, #bbdefb); 
            border-radius: 12px; 
            padding: 20px; 
            margin: 20px 0; 
            text-align: center;
        }
        
        .summary h2 { 
            color: #1565c0; 
            margin-bottom: 15px;
        }
        
        .formula-box { 
            background: #f8f9fa; 
            border-left: 4px solid #6c757d; 
            padding: 15px; 
            margin: 15px 0; 
            font-family: 'Courier New', monospace; 
            border-radius: 6px;
        }
        
        button { 
            background: linear-gradient(45deg, #007bff, #0056b3); 
            color: white; 
            border: none; 
            padding: 12px 25px; 
            border-radius: 8px; 
            cursor: pointer; 
            font-size: 1em; 
            margin: 10px 5px;
            transition: all 0.3s ease;
        }
        
        button:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 4px 15px rgba(0,123,255,0.3);
        }
        
        .highlight { 
            background: #fff3cd; 
            border: 2px solid #ffc107; 
            border-radius: 8px; 
            padding: 15px; 
            margin: 15px 0;
        }
        
        .log-output { 
            background: #2d3748; 
            color: #e2e8f0; 
            font-family: 'Courier New', monospace; 
            padding: 15px; 
            border-radius: 8px; 
            max-height: 300px; 
            overflow-y: auto; 
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ VALIDA√á√ÉO FINAL - Sub-Scores 100% Precisos</h1>
        
        <div class="highlight">
            <h3>‚úÖ Objetivo: Garantir que os 4 sub-scores sejam 100% fi√©is √†s an√°lises t√©cnicas</h3>
            <p>Este sistema valida a precis√£o dos c√°lculos de <strong>Din√¢mica</strong>, <strong>T√©cnico</strong>, <strong>Loudness</strong> e <strong>Frequ√™ncia</strong></p>
        </div>
        
        <div style="text-align: center; margin: 20px 0;">
            <button onclick="runComprehensiveValidation()">üöÄ Executar Valida√ß√£o Completa</button>
            <button onclick="testRealAudio()">üéµ Testar com √Åudio Real</button>
            <button onclick="showFormulas()">üìê Mostrar F√≥rmulas</button>
            <button onclick="clearResults()">üßπ Limpar</button>
        </div>
        
        <div id="results" style="display: none;">
            <div class="summary" id="overallSummary">
                <h2>üìä Resumo da Valida√ß√£o</h2>
                <div id="summaryContent"></div>
            </div>
            
            <div class="validation-grid" id="validationGrid"></div>
            
            <table class="comparison-table" id="comparisonTable" style="display: none;">
                <thead>
                    <tr>
                        <th>Categoria</th>
                        <th>Score Final</th>
                        <th>M√©todo Usado</th>
                        <th>Confian√ßa</th>
                        <th>Status</th>
                        <th>Dados Dispon√≠veis</th>
                    </tr>
                </thead>
                <tbody id="comparisonBody"></tbody>
            </table>
            
            <div id="formulasSection" style="display: none;">
                <h2>üìê F√≥rmulas de C√°lculo</h2>
                
                <h3>üî∏ Din√¢mica (Advanced Method)</h3>
                <div class="formula-box">
                    DR_score = tolerance_function(DR_value, target_DR, tolerance_DR)<br>
                    LRA_score = tolerance_function(LRA_value, target_LRA, tolerance_LRA)<br>
                    Crest_score = tolerance_function(Crest_value, target_Crest, tolerance_Crest)<br>
                    <strong>Final_Dynamics = round((DR_score + LRA_score + Crest_score) / 3 * 100)</strong>
                </div>
                
                <h3>üî∏ T√©cnico (Advanced Method)</h3>
                <div class="formula-box">
                    TruePeak_score = tolerance_function(TP_value, target_TP, tolerance_TP, invert=true)<br>
                    DCOffset_score = tolerance_function(DC_value, 0, 0.02, invert=true)<br>
                    THD_score = tolerance_function(THD_value, 1, 1, invert=true)<br>
                    Clipping_score = clipping_samples == 0 ? 1 : (samples < 10 ? 0.7 : 0)<br>
                    <strong>Final_Technical = round((TP_score + DC_score + THD_score + Clip_score) / 4 * 100)</strong>
                </div>
                
                <h3>üî∏ Loudness (Advanced Method)</h3>
                <div class="formula-box">
                    LUFS_score = tolerance_function(LUFS_value, target_LUFS, tolerance_LUFS)<br>
                    <strong>Final_Loudness = round(LUFS_score * 100)</strong>
                </div>
                
                <h3>üî∏ Frequ√™ncia (Advanced Method)</h3>
                <div class="formula-box">
                    Centroid_score = tolerance_function(Centroid_value, 2500, 1200)<br>
                    Rolloff50_score = tolerance_function(Rolloff50_value, 3000, 1200)<br>
                    Rolloff85_score = tolerance_function(Rolloff85_value, 8000, 2500)<br>
                    <strong>Final_Frequency = round((Centroid_score + Rolloff50_score + Rolloff85_score) / 3 * 100)</strong>
                </div>
                
                <h3>üî∏ Fun√ß√£o de Toler√¢ncia</h3>
                <div class="formula-box">
                    tolerance_function(value, target, tolerance, invert=false) {<br>
                    &nbsp;&nbsp;diff = |value - target|<br>
                    &nbsp;&nbsp;if (diff <= tolerance) return 1.0<br>
                    &nbsp;&nbsp;if (diff >= 2*tolerance) return 0.0<br>
                    &nbsp;&nbsp;return 1 - (diff - tolerance) / tolerance<br>
                    }
                </div>
            </div>
            
            <div id="logOutput" class="log-output" style="display: none;"></div>
        </div>
        
        <input type="file" id="audioFile" accept="audio/*" style="display: none;">
    </div>

    <script type="module">
        // Simular importa√ß√£o do corretor
        class SubScoreCorrector {
            constructor() {
                this.PRECISION_TOLERANCE = 0.1;
                this.DEBUG = true;
            }

            correctSubScores(baseAnalysis, reference = null) {
                const td = baseAnalysis.technicalData;
                const ref = reference || this.getDefaultReference();

                const advancedScores = this.calculateAdvancedSubScores(td, ref);
                const fallbackScores = this.calculateFallbackSubScores(td, ref);
                const finalScores = this.selectBestScores(advancedScores, fallbackScores, td, ref);
                const validation = this.validatePrecision(finalScores, td, ref);

                baseAnalysis.qualityBreakdown = finalScores;
                baseAnalysis.subScoreValidation = validation;

                return baseAnalysis;
            }

            calculateAdvancedSubScores(td, ref) {
                const targets = this.getTargetsAndTolerances(ref);
                const scores = {};

                Object.keys(targets).forEach(metricKey => {
                    const config = targets[metricKey];
                    const value = td[metricKey];
                    scores[metricKey] = this.calculateToleranceScore(value, config.target, config.tolerance, config.invert);
                });

                return {
                    dynamics: this.aggregateCategory(['dynamicRange', 'lra', 'crestFactor'], scores),
                    technical: this.aggregateCategory(['truePeakDbtp', 'dcOffset', 'thdPercent', 'clippingSamples'], scores, td),
                    loudness: this.aggregateCategory(['lufsIntegrated'], scores),
                    frequency: this.aggregateCategory(['spectralCentroid', 'spectralRolloff50', 'spectralRolloff85'], scores),
                    method: 'advanced',
                    individualScores: scores,
                    targets: targets
                };
            }

            calculateFallbackSubScores(td, ref) {
                const safe = (v, def = 0) => Number.isFinite(v) ? v : def;
                
                const lufsInt = safe(td.lufsIntegrated, safe(td.rms));
                const dr = safe(td.dynamicRange);
                const crest = safe(td.crestFactor);
                const corr = safe(td.stereoCorrelation, 0);
                const centroid = safe(td.spectralCentroid);
                
                const refLufs = ref?.lufs_target ?? -14;
                const refDR = ref?.dr_target ?? 10;
                const freqIdealLow = 1800, freqIdealHigh = 3200;
                
                const scoreLoud = 100 - Math.min(100, Math.abs(lufsInt - refLufs) * 6);
                const scoreDyn = 100 - Math.min(100, Math.abs(dr - refDR) * 10);
                
                let scoreTech = 100;
                if (safe(td.clippingSamples) > 0) scoreTech -= 20;
                if (Math.abs(safe(td.dcOffset)) > 0.02) scoreTech -= 10;
                if (crest < 6) scoreTech -= 15; 
                else if (crest < 8) scoreTech -= 5;
                if (corr < -0.2) scoreTech -= 15;
                
                let scoreFreq;
                if (!Number.isFinite(centroid)) {
                    scoreFreq = 50;
                } else if (centroid < freqIdealLow) {
                    scoreFreq = 100 - Math.min(60, (freqIdealLow - centroid) / freqIdealLow * 100);
                } else if (centroid > freqIdealHigh) {
                    scoreFreq = 100 - Math.min(60, (centroid - freqIdealHigh) / freqIdealHigh * 100);
                } else {
                    scoreFreq = 100;
                }
                
                const clamp = v => Math.max(0, Math.min(100, Math.round(v)));
                
                return {
                    dynamics: clamp(scoreDyn),
                    technical: clamp(scoreTech), 
                    loudness: clamp(scoreLoud),
                    frequency: clamp(scoreFreq),
                    method: 'fallback'
                };
            }

            calculateToleranceScore(value, target, tolerance, invert = false) {
                if (!Number.isFinite(value) || !Number.isFinite(target) || !Number.isFinite(tolerance) || tolerance <= 0) {
                    return null;
                }
                
                const diff = value - target;
                const adiff = Math.abs(diff);
                
                if (invert) {
                    if (diff <= 0) return 1;
                    if (diff >= 2 * tolerance) return 0;
                    if (diff <= tolerance) return 1 - (diff / tolerance) * 0.5;
                    return 1 - (0.5 + (diff - tolerance) / tolerance * 0.5);
                }
                
                if (adiff <= tolerance) return 1;
                if (adiff >= 2 * tolerance) return 0;
                return 1 - (adiff - tolerance) / tolerance;
            }

            aggregateCategory(metricKeys, scores, technicalData = null) {
                const validScores = [];
                
                metricKeys.forEach(key => {
                    if (key === 'clippingSamples' && technicalData) {
                        const samples = technicalData.clippingSamples;
                        const clipScore = Number.isFinite(samples) ? (samples === 0 ? 1 : samples < 10 ? 0.7 : 0) : null;
                        if (clipScore !== null) validScores.push(clipScore);
                    } else if (scores[key] !== null && Number.isFinite(scores[key])) {
                        validScores.push(scores[key]);
                    }
                });
                
                if (validScores.length === 0) return 50;
                
                const average = validScores.reduce((sum, score) => sum + score, 0) / validScores.length;
                return Math.round(average * 100);
            }

            selectBestScores(advanced, fallback, td, ref) {
                const differences = {
                    dynamics: Math.abs(advanced.dynamics - fallback.dynamics),
                    technical: Math.abs(advanced.technical - fallback.technical),
                    loudness: Math.abs(advanced.loudness - fallback.loudness),
                    frequency: Math.abs(advanced.frequency - fallback.frequency)
                };
                
                const maxDiff = Math.max(...Object.values(differences));
                
                if (maxDiff <= 5) {
                    return {
                        dynamics: advanced.dynamics,
                        technical: advanced.technical,
                        loudness: advanced.loudness,
                        frequency: advanced.frequency,
                        source: 'advanced',
                        confidence: 'high',
                        differences: differences
                    };
                }
                
                return {
                    dynamics: advanced.dynamics, // Preferir advanced quando poss√≠vel
                    technical: advanced.technical,
                    loudness: advanced.loudness,
                    frequency: advanced.frequency,
                    source: 'hybrid',
                    confidence: 'medium',
                    differences: differences
                };
            }

            validatePrecision(finalScores, td, ref) {
                const validation = {
                    timestamp: new Date().toISOString(),
                    summary: { status: 'unknown', score: 0, issues: [] },
                    categories: {}
                };
                
                let totalScore = 0;
                let categoryCount = 0;
                
                ['dynamics', 'technical', 'loudness', 'frequency'].forEach(category => {
                    const score = finalScores[category];
                    const dataCheck = this.checkDataAvailability(category, td);
                    
                    let categoryStatus = 'ok';
                    if (!Number.isFinite(score) || score < 0 || score > 100) {
                        categoryStatus = 'invalid';
                        validation.summary.issues.push(`${category}: score inv√°lido`);
                    } else if (dataCheck.completeness < 0.5) {
                        categoryStatus = 'insufficient_data';
                        validation.summary.issues.push(`${category}: dados insuficientes`);
                    }
                    
                    validation.categories[category] = {
                        score: score,
                        status: categoryStatus,
                        dataCompleteness: dataCheck.completeness,
                        missingMetrics: dataCheck.missing
                    };
                    
                    if (Number.isFinite(score)) {
                        totalScore += score;
                        categoryCount++;
                    }
                });
                
                validation.summary.score = categoryCount > 0 ? Math.round(totalScore / categoryCount) : 0;
                
                if (validation.summary.issues.length === 0) {
                    validation.summary.status = 'excellent';
                } else if (validation.summary.issues.length <= 2) {
                    validation.summary.status = 'good';
                } else {
                    validation.summary.status = 'needs_attention';
                }
                
                return validation;
            }

            checkDataAvailability(category, td) {
                const categoryMetrics = {
                    dynamics: ['dynamicRange', 'lra', 'crestFactor'],
                    technical: ['truePeakDbtp', 'dcOffset', 'thdPercent', 'clippingSamples'],
                    loudness: ['lufsIntegrated'],
                    frequency: ['spectralCentroid', 'spectralRolloff50', 'spectralRolloff85']
                };
                
                const metrics = categoryMetrics[category] || [];
                const available = metrics.filter(metric => Number.isFinite(td[metric])).length;
                
                return {
                    total: metrics.length,
                    available: available,
                    completeness: metrics.length > 0 ? available / metrics.length : 0,
                    missing: metrics.filter(metric => !Number.isFinite(td[metric]))
                };
            }

            getTargetsAndTolerances(ref = null) {
                return {
                    lufsIntegrated: { target: ref?.lufs_target ?? -14, tolerance: ref?.tol_lufs ?? 1 },
                    dynamicRange: { target: ref?.dr_target ?? 10, tolerance: ref?.tol_dr ?? 3 },
                    lra: { target: ref?.lra_target ?? 7, tolerance: ref?.tol_lra ?? 3 },
                    crestFactor: { target: 10, tolerance: 4 },
                    truePeakDbtp: { target: ref?.true_peak_target ?? -1, tolerance: ref?.tol_true_peak ?? 1, invert: true },
                    dcOffset: { target: 0, tolerance: 0.02, invert: true },
                    spectralCentroid: { target: 2500, tolerance: 1200 },
                    spectralRolloff50: { target: 3000, tolerance: 1200 },
                    spectralRolloff85: { target: 8000, tolerance: 2500 },
                    thdPercent: { target: 1, tolerance: 1, invert: true }
                };
            }

            getDefaultReference() {
                return {
                    lufs_target: -14,
                    tol_lufs: 1,
                    dr_target: 10,
                    tol_dr: 3,
                    lra_target: 7,
                    tol_lra: 3,
                    true_peak_target: -1,
                    tol_true_peak: 1
                };
            }
        }

        const corrector = new SubScoreCorrector();
        let currentResults = null;

        // Dados de teste sint√©ticos
        const testCases = [
            {
                name: "üéµ Mix Profissional",
                technicalData: {
                    lufsIntegrated: -14.2,
                    dynamicRange: 9.8,
                    lra: 6.5,
                    crestFactor: 9.2,
                    truePeakDbtp: -0.8,
                    dcOffset: 0.002,
                    spectralCentroid: 2600,
                    spectralRolloff50: 3100,
                    spectralRolloff85: 7800,
                    thdPercent: 0.6,
                    clippingSamples: 0,
                    stereoCorrelation: 0.25
                }
            },
            {
                name: "üìª Mix Comercial",
                technicalData: {
                    lufsIntegrated: -11.5,
                    dynamicRange: 6.2,
                    lra: 4.8,
                    crestFactor: 7.1,
                    truePeakDbtp: -0.3,
                    dcOffset: 0.008,
                    spectralCentroid: 3200,
                    spectralRolloff50: 3800,
                    spectralRolloff85: 9200,
                    thdPercent: 1.2,
                    clippingSamples: 15,
                    stereoCorrelation: 0.15
                }
            },
            {
                name: "üéß Mix Audi√≥filo",
                technicalData: {
                    lufsIntegrated: -16.8,
                    dynamicRange: 12.5,
                    lra: 8.2,
                    crestFactor: 11.8,
                    truePeakDbtp: -2.1,
                    dcOffset: 0.001,
                    spectralCentroid: 2200,
                    spectralRolloff50: 2700,
                    spectralRolloff85: 6800,
                    thdPercent: 0.3,
                    clippingSamples: 0,
                    stereoCorrelation: 0.35
                }
            }
        ];

        function runComprehensiveValidation() {
            clearResults();
            
            const results = [];
            const logOutput = document.getElementById('logOutput');
            logOutput.style.display = 'block';
            logOutput.innerHTML = '<strong>üéØ Log de Valida√ß√£o:</strong><br><br>';
            
            testCases.forEach((testCase, index) => {
                logOutput.innerHTML += `<span style="color: #4fc3f7;">Teste ${index + 1}: ${testCase.name}</span><br>`;
                
                const baseAnalysis = { technicalData: testCase.technicalData };
                const correctedAnalysis = corrector.correctSubScores(baseAnalysis);
                
                logOutput.innerHTML += `  Din√¢mica: ${correctedAnalysis.qualityBreakdown.dynamics}/100<br>`;
                logOutput.innerHTML += `  T√©cnico: ${correctedAnalysis.qualityBreakdown.technical}/100<br>`;
                logOutput.innerHTML += `  Loudness: ${correctedAnalysis.qualityBreakdown.loudness}/100<br>`;
                logOutput.innerHTML += `  Frequ√™ncia: ${correctedAnalysis.qualityBreakdown.frequency}/100<br>`;
                logOutput.innerHTML += `  Status: ${correctedAnalysis.subScoreValidation.summary.status}<br><br>`;
                
                results.push({
                    name: testCase.name,
                    analysis: correctedAnalysis
                });
            });
            
            currentResults = results;
            displayValidationResults(results);
            document.getElementById('results').style.display = 'block';
        }

        function displayValidationResults(results) {
            const summaryContent = document.getElementById('summaryContent');
            const validationGrid = document.getElementById('validationGrid');
            const comparisonTable = document.getElementById('comparisonTable');
            const comparisonBody = document.getElementById('comparisonBody');
            
            // Calcular estat√≠sticas gerais
            let totalExcellent = 0;
            let totalGood = 0;
            let totalCritical = 0;
            
            results.forEach(result => {
                const status = result.analysis.subScoreValidation.summary.status;
                if (status === 'excellent') totalExcellent++;
                else if (status === 'good') totalGood++;
                else totalCritical++;
            });
            
            // Atualizar summary
            summaryContent.innerHTML = `
                <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 20px;">
                    <div>
                        <div style="font-size: 2em; font-weight: bold; color: #28a745;">${totalExcellent}</div>
                        <div>Excelentes</div>
                    </div>
                    <div>
                        <div style="font-size: 2em; font-weight: bold; color: #ffc107;">${totalGood}</div>
                        <div>Bons</div>
                    </div>
                    <div>
                        <div style="font-size: 2em; font-weight: bold; color: #dc3545;">${totalCritical}</div>
                        <div>Cr√≠ticos</div>
                    </div>
                    <div>
                        <div style="font-size: 2em; font-weight: bold; color: #007bff;">${Math.round(totalExcellent / results.length * 100)}%</div>
                        <div>Taxa de Sucesso</div>
                    </div>
                </div>
            `;
            
            // Atualizar grid de valida√ß√£o
            validationGrid.innerHTML = '';
            results.forEach(result => {
                const validation = result.analysis.subScoreValidation;
                const scores = result.analysis.qualityBreakdown;
                const status = validation.summary.status;
                
                const card = document.createElement('div');
                card.className = `validation-card ${status}`;
                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-title">${result.name}</div>
                        <div class="score-display ${status}">${validation.summary.score}/100</div>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0;">
                        <div>‚ö° Din√¢mica: <strong>${scores.dynamics}</strong></div>
                        <div>üîß T√©cnico: <strong>${scores.technical}</strong></div>
                        <div>üîä Loudness: <strong>${scores.loudness}</strong></div>
                        <div>üåà Frequ√™ncia: <strong>${scores.frequency}</strong></div>
                    </div>
                    <div class="metrics-details">
                        <div>Status: <span class="status-${status}">${status.toUpperCase()}</span></div>
                        <div>M√©todo: ${scores.source || 'advanced'}</div>
                        <div>Confian√ßa: ${scores.confidence || 'high'}</div>
                        ${validation.summary.issues.length > 0 ? `<div>Issues: ${validation.summary.issues.join(', ')}</div>` : ''}
                    </div>
                `;
                validationGrid.appendChild(card);
            });
            
            // Atualizar tabela de compara√ß√£o
            comparisonBody.innerHTML = '';
            results.forEach(result => {
                const validation = result.analysis.subScoreValidation;
                const scores = result.analysis.qualityBreakdown;
                
                ['dynamics', 'technical', 'loudness', 'frequency'].forEach(category => {
                    const categoryData = validation.categories[category];
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td><strong>${result.name} - ${category}</strong></td>
                        <td style="font-size: 1.2em; font-weight: bold;">${scores[category]}/100</td>
                        <td>${scores.source || 'advanced'}</td>
                        <td>${scores.confidence || 'high'}</td>
                        <td><span class="status-${categoryData?.status || 'ok'}">${categoryData?.status || 'ok'}</span></td>
                        <td>${Math.round((categoryData?.dataCompleteness || 0) * 100)}%</td>
                    `;
                    comparisonBody.appendChild(row);
                });
            });
            
            comparisonTable.style.display = 'table';
        }

        function testRealAudio() {
            document.getElementById('audioFile').click();
        }

        function showFormulas() {
            const formulasSection = document.getElementById('formulasSection');
            formulasSection.style.display = formulasSection.style.display === 'none' ? 'block' : 'none';
        }

        function clearResults() {
            document.getElementById('results').style.display = 'none';
            document.getElementById('formulasSection').style.display = 'none';
            document.getElementById('logOutput').style.display = 'none';
            currentResults = null;
        }

        // Event listeners
        document.getElementById('audioFile').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                // Simular an√°lise de √°udio real
                const fakeAnalysis = {
                    technicalData: {
                        lufsIntegrated: -13.5 + Math.random() * 3,
                        dynamicRange: 8 + Math.random() * 4,
                        lra: 6 + Math.random() * 3,
                        crestFactor: 9 + Math.random() * 2,
                        truePeakDbtp: -0.5 + Math.random() * 0.5,
                        dcOffset: Math.random() * 0.01,
                        spectralCentroid: 2300 + Math.random() * 400,
                        thdPercent: 0.5 + Math.random() * 0.5,
                        clippingSamples: Math.floor(Math.random() * 5)
                    }
                };
                
                const correctedAnalysis = corrector.correctSubScores(fakeAnalysis);
                
                const results = [{
                    name: `üéµ ${file.name}`,
                    analysis: correctedAnalysis
                }];
                
                currentResults = results;
                displayValidationResults(results);
                document.getElementById('results').style.display = 'block';
                
            } catch (error) {
                alert(`Erro ao processar √°udio: ${error.message}`);
            }
        });

        // Expor fun√ß√µes globalmente
        window.runComprehensiveValidation = runComprehensiveValidation;
        window.testRealAudio = testRealAudio;
        window.showFormulas = showFormulas;
        window.clearResults = clearResults;

        console.log('üéØ Sistema de valida√ß√£o de precis√£o carregado!');
        console.log('Execute runComprehensiveValidation() para come√ßar');
    </script>
</body>
</html>
