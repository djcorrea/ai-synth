<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîß Teste Direto Scoring - Sem Import</title>
    <style>
        body { font-family: monospace; padding: 20px; background: #0a0a0a; color: #00ff00; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #333; }
        button { padding: 10px 20px; margin: 10px; background: #333; color: #fff; border: none; cursor: pointer; }
        button:hover { background: #555; }
        #results { margin-top: 20px; }
        .score-display { font-size: 18px; font-weight: bold; margin: 10px 0; padding: 10px; border-left: 3px solid #00ff00; }
        .status { padding: 10px; margin: 10px 0; }
        .success { background: #001a00; border-left: 3px solid #00ff00; }
        .error { background: #1a0000; border-left: 3px solid #ff0000; color: #ff6666; }
        .warning { background: #1a1a00; border-left: 3px solid #ffff00; color: #ffff66; }
    </style>
</head>
<body>
    <h1>üîß Teste Direto Scoring - Sem Import</h1>
    
    <div class="test-section">
        <h2>üéØ Teste com Scripts Inclu√≠dos</h2>
        <p>Este teste carrega os scripts diretamente sem dynamic import</p>
        <button onclick="executarTeste()">üöÄ Executar Teste</button>
        <button onclick="limparTeste()">üßπ Limpar</button>
    </div>
    
    <div id="results"></div>
    
    <!-- Incluir scoring.js diretamente -->
    <script src="./lib/audio/features/scoring.js"></script>
    
    <script>
        console.log('üîß [DIRECT_TEST] Iniciando teste direto');
        
        let testResults = [];
        
        function addResult(status, message, details = '') {
            const result = { status, message, details, timestamp: new Date().toLocaleTimeString() };
            testResults.push(result);
            updateDisplay();
        }
        
        function updateDisplay() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = testResults.map(result => `
                <div class="status ${result.status}">
                    <strong>[${result.timestamp}] ${result.message}</strong>
                    ${result.details ? `<div style="background: #1a1a1a; padding: 10px; margin: 10px 0; font-size: 12px;">${result.details}</div>` : ''}
                </div>
            `).join('');
        }
        
        async function executarTeste() {
            console.log('\\nüîß [DIRECT_TEST] ======= TESTE DIRETO =======');
            testResults = [];
            addResult('warning', 'üîß Iniciando teste direto...');
            
            try {
                // 1. Verificar se scoring.js carregou
                addResult('warning', 'üì¶ Verificando carregamento do scoring.js...');
                
                if (typeof computeMixScore === 'function') {
                    addResult('success', '‚úÖ scoring.js carregado com sucesso');
                } else {
                    addResult('error', '‚ùå scoring.js n√£o encontrado - verificando window...');
                    
                    // Tentar acessar via window
                    if (window.computeMixScore) {
                        addResult('success', '‚úÖ scoring.js encontrado via window');
                    } else {
                        addResult('error', '‚ùå scoring.js n√£o acess√≠vel');
                        return;
                    }
                }
                
                // 2. Testar carregamento de refer√™ncias
                addResult('warning', 'üìã Testando carregamento de refer√™ncias...');
                
                const referencias = [
                    { nome: 'funk_mandela', url: '/refs/out/funk_mandela.json' },
                    { nome: 'trance', url: '/refs/out/trance.json' },
                    { nome: 'eletronico', url: '/refs/out/eletronico.json' }
                ];
                
                const refData = {};
                
                for (const ref of referencias) {
                    try {
                        addResult('warning', `üìã Carregando ${ref.nome}...`);
                        const response = await fetch(ref.url);
                        if (response.ok) {
                            const data = await response.json();
                            refData[ref.nome] = data;
                            addResult('success', `‚úÖ ${ref.nome} carregado`, 
                                `lufs_target: ${data.lufs_target}, dr_target: ${data.dr_target}`);
                        } else {
                            throw new Error(`HTTP ${response.status}`);
                        }
                    } catch (error) {
                        addResult('error', `‚ùå Erro ao carregar ${ref.nome}: ${error.message}`);
                        
                        // Usar fallback
                        const fallbacks = {
                            funk_mandela: { lufs_target: -11.5, dr_target: 6.8, stereo_target: 0.2, tol_lufs: 2.5, tol_dr: 2.0, tol_stereo: 0.3 },
                            trance: { lufs_target: -12.8, dr_target: 9.2, stereo_target: 0.35, tol_lufs: 1.8, tol_dr: 2.5, tol_stereo: 0.4 },
                            eletronico: { lufs_target: -13.2, dr_target: 8.5, stereo_target: 0.3, tol_lufs: 2.0, tol_dr: 2.2, tol_stereo: 0.35 }
                        };
                        refData[ref.nome] = fallbacks[ref.nome];
                        addResult('warning', `‚ö†Ô∏è Usando fallback para ${ref.nome}`);
                    }
                }
                
                // 3. Testar scoring
                addResult('warning', 'üéØ Testando sistema de scoring...');
                
                const testTechnicalData = {
                    lufsIntegrated: -12.3,
                    truePeakDbtp: -0.8,
                    dr: 8.2,
                    lra: 6.1,
                    stereoCorrelation: 0.25,
                    dynamicRange: 8.2,
                    dr_stat: 8.2,
                    crestFactor: 12.3,
                    spectralCentroid: 2800,
                    spectralFlatness: 0.18,
                    spectralRolloff85: 7500,
                    dcOffsetLeft: 0.001,
                    dcOffsetRight: -0.002,
                    clippingPct: 0.1
                };
                
                const scores = {};
                
                for (const [genero, reference] of Object.entries(refData)) {
                    try {
                        addResult('warning', `üéµ Calculando score para ${genero}...`);
                        
                        // Usar fun√ß√£o global ou window
                        const computeFunc = typeof computeMixScore === 'function' ? computeMixScore : window.computeMixScore;
                        const result = computeFunc(testTechnicalData, reference);
                        scores[genero] = result;
                        
                        addResult('success', `‚úÖ ${genero}: ${result.scorePct}% (${result.classification})`,
                            `Method: ${result.method}, Engine: ${result.engineVersion}`);
                            
                    } catch (error) {
                        addResult('error', `‚ùå Erro ao calcular score para ${genero}: ${error.message}`);
                    }
                }
                
                // 4. Valida√ß√£o final
                addResult('warning', 'üîç Valida√ß√£o final...');
                
                const scoreValues = Object.values(scores).map(s => s.scorePct);
                const uniqueScores = new Set(scoreValues);
                
                if (uniqueScores.size === scoreValues.length && scoreValues.length === 3) {
                    addResult('success', '‚úÖ SUCESSO: Todos os scores s√£o diferentes!');
                    
                    const resumo = Object.entries(scores).map(([genero, result]) => 
                        `${genero}: ${result.scorePct}%`
                    ).join(' | ');
                    
                    addResult('success', 'üéâ Sistema funcionando corretamente!', resumo);
                } else {
                    addResult('error', '‚ùå FALHA: Scores id√™nticos ou incompletos');
                    addResult('error', `Scores: ${scoreValues.join(', ')}`);
                }
                
            } catch (error) {
                addResult('error', `‚ùå ERRO CR√çTICO: ${error.message}`);
                console.error('[DIRECT_TEST] Erro:', error);
            }
        }
        
        window.executarTeste = executarTeste;
        
        window.limparTeste = () => {
            testResults = [];
            updateDisplay();
            console.clear();
            console.log('üîß [DIRECT_TEST] Teste limpo');
        };
        
        // Verificar se scoring.js carregou ao inicializar
        setTimeout(() => {
            if (typeof computeMixScore === 'function' || window.computeMixScore) {
                console.log('‚úÖ [DIRECT_TEST] scoring.js detectado - pronto para teste');
            } else {
                console.error('‚ùå [DIRECT_TEST] scoring.js n√£o encontrado');
            }
        }, 1000);
    </script>
</body>
</html>
